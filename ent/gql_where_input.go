// Code generated by entc, DO NOT EDIT.

package ent

import (
	"backend/ent/car"
	"backend/ent/plane"
	"backend/ent/predicate"
	"backend/ent/schema/pulid"
	"fmt"
	"time"
)

// CarWhereInput represents a where input for filtering Car queries.
type CarWhereInput struct {
	Not *CarWhereInput   `json:"not,omitempty"`
	Or  []*CarWhereInput `json:"or,omitempty"`
	And []*CarWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "wheelPressure" field predicates.
	WheelPressure      *float64  `json:"wheelpressure,omitempty"`
	WheelPressureNEQ   *float64  `json:"wheelpressureNEQ,omitempty"`
	WheelPressureIn    []float64 `json:"wheelpressureIn,omitempty"`
	WheelPressureNotIn []float64 `json:"wheelpressureNotIn,omitempty"`
	WheelPressureGT    *float64  `json:"wheelpressureGT,omitempty"`
	WheelPressureGTE   *float64  `json:"wheelpressureGTE,omitempty"`
	WheelPressureLT    *float64  `json:"wheelpressureLT,omitempty"`
	WheelPressureLTE   *float64  `json:"wheelpressureLTE,omitempty"`
}

// Filter applies the CarWhereInput filter on the CarQuery builder.
func (i *CarWhereInput) Filter(q *CarQuery) (*CarQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering cars.
// An error is returned if the input is empty or invalid.
func (i *CarWhereInput) P() (predicate.Car, error) {
	var predicates []predicate.Car
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, car.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Car, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, car.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Car, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, car.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, car.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, car.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, car.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, car.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, car.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, car.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, car.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, car.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, car.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, car.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, car.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, car.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, car.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, car.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, car.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, car.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, car.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, car.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, car.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, car.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, car.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, car.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, car.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, car.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, car.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, car.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, car.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, car.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, car.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, car.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, car.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, car.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, car.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, car.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, car.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, car.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, car.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, car.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, car.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, car.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, car.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, car.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, car.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, car.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, car.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, car.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, car.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, car.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, car.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, car.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, car.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, car.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.WheelPressure != nil {
		predicates = append(predicates, car.WheelPressureEQ(*i.WheelPressure))
	}
	if i.WheelPressureNEQ != nil {
		predicates = append(predicates, car.WheelPressureNEQ(*i.WheelPressureNEQ))
	}
	if len(i.WheelPressureIn) > 0 {
		predicates = append(predicates, car.WheelPressureIn(i.WheelPressureIn...))
	}
	if len(i.WheelPressureNotIn) > 0 {
		predicates = append(predicates, car.WheelPressureNotIn(i.WheelPressureNotIn...))
	}
	if i.WheelPressureGT != nil {
		predicates = append(predicates, car.WheelPressureGT(*i.WheelPressureGT))
	}
	if i.WheelPressureGTE != nil {
		predicates = append(predicates, car.WheelPressureGTE(*i.WheelPressureGTE))
	}
	if i.WheelPressureLT != nil {
		predicates = append(predicates, car.WheelPressureLT(*i.WheelPressureLT))
	}
	if i.WheelPressureLTE != nil {
		predicates = append(predicates, car.WheelPressureLTE(*i.WheelPressureLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("backend/ent: empty predicate CarWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return car.And(predicates...), nil
	}
}

// PlaneWhereInput represents a where input for filtering Plane queries.
type PlaneWhereInput struct {
	Not *PlaneWhereInput   `json:"not,omitempty"`
	Or  []*PlaneWhereInput `json:"or,omitempty"`
	And []*PlaneWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "altitude" field predicates.
	Altitude      *float64  `json:"altitude,omitempty"`
	AltitudeNEQ   *float64  `json:"altitudeNEQ,omitempty"`
	AltitudeIn    []float64 `json:"altitudeIn,omitempty"`
	AltitudeNotIn []float64 `json:"altitudeNotIn,omitempty"`
	AltitudeGT    *float64  `json:"altitudeGT,omitempty"`
	AltitudeGTE   *float64  `json:"altitudeGTE,omitempty"`
	AltitudeLT    *float64  `json:"altitudeLT,omitempty"`
	AltitudeLTE   *float64  `json:"altitudeLTE,omitempty"`
}

// Filter applies the PlaneWhereInput filter on the PlaneQuery builder.
func (i *PlaneWhereInput) Filter(q *PlaneQuery) (*PlaneQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering planes.
// An error is returned if the input is empty or invalid.
func (i *PlaneWhereInput) P() (predicate.Plane, error) {
	var predicates []predicate.Plane
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, plane.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Plane, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, plane.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Plane, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, plane.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, plane.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, plane.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, plane.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, plane.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, plane.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, plane.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, plane.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, plane.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, plane.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, plane.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, plane.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, plane.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, plane.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, plane.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, plane.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, plane.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, plane.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, plane.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, plane.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, plane.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, plane.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, plane.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, plane.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, plane.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, plane.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, plane.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, plane.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, plane.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, plane.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, plane.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, plane.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, plane.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, plane.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, plane.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, plane.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, plane.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, plane.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, plane.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, plane.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, plane.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, plane.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, plane.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, plane.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, plane.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, plane.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, plane.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, plane.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, plane.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, plane.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, plane.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, plane.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, plane.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Altitude != nil {
		predicates = append(predicates, plane.AltitudeEQ(*i.Altitude))
	}
	if i.AltitudeNEQ != nil {
		predicates = append(predicates, plane.AltitudeNEQ(*i.AltitudeNEQ))
	}
	if len(i.AltitudeIn) > 0 {
		predicates = append(predicates, plane.AltitudeIn(i.AltitudeIn...))
	}
	if len(i.AltitudeNotIn) > 0 {
		predicates = append(predicates, plane.AltitudeNotIn(i.AltitudeNotIn...))
	}
	if i.AltitudeGT != nil {
		predicates = append(predicates, plane.AltitudeGT(*i.AltitudeGT))
	}
	if i.AltitudeGTE != nil {
		predicates = append(predicates, plane.AltitudeGTE(*i.AltitudeGTE))
	}
	if i.AltitudeLT != nil {
		predicates = append(predicates, plane.AltitudeLT(*i.AltitudeLT))
	}
	if i.AltitudeLTE != nil {
		predicates = append(predicates, plane.AltitudeLTE(*i.AltitudeLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("backend/ent: empty predicate PlaneWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return plane.And(predicates...), nil
	}
}
